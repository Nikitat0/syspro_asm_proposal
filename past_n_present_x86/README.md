# Прошлое и настоящее

> **Сложность**: средняя  
> **ISA**: x86-64

Традиционно собеседование на профиль "Системное программирование" начинается с
похожей задачи. Покажите, на что вы способны!

## Условие

Предоставьте не менее чем пять **различных** реализаций функции
`int isEven(int n)`, возвращающей 1 если n чётно и 0 если n нечётно, на
ассемблере NASM.

Каждая реализация должна находиться в отдельном файле в корне репозитория с
именем impl\*.nasm.

Реализации считаются **различными**, если выполняется следующее. **Одинаковые**
инструкции могут использоватся только в одной из реализаций. Инструкция `ret` в
конце функции не попадает под это ограничение. Инструкции считаются одинаковыми
если у них совпадает опкод и/или мнемоника. Пример:

| NASM       | Машинный код | Опкод   |
| :--------- | :----------- | :------ |
| `inc al`   | `fe c0`      | `fe`    |
| `inc eax`  | `ff c0`      | `ff`    |
| `setpo al` | `0f 9b c0`   | `0f 9b` |
| `setnp al` | `0f 9b c0`   | `0f 9b` |

У `inc al` и `inc eax` совпадает мнемоника, хотя опкоды разные. `setnp` и
`setpo` — ­две мнемоники для одной и той же инструкции.

## Полезные материалы

- [Регистр флагов](https://en.wikipedia.org/wiki/FLAGS_register)
- [Соглашение о вызовах на Linux x86-64](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)
- [Справочник инструкциям x86-64](https://www.felixcloutier.com/x86/)
- [Что такое опкод и мнемоника?](https://stackoverflow.com/questions/17638888/difference-between-opcode-byte-code-mnemonics-machine-code-and-assembly)
