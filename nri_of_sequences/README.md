# НИИ последовательностей

> **Сложность**: высокая  
> **ISA**: x86-64

В недавно образованном НИИ изучают последовательности натуральных чисел. Часть
сотрудников предложила использовать компьютерные технологии в работе института.
Для работы с последовательностями, особенно бесконечными, удобно использовать
генераторы. К сожалению, в языке Си, который знают математики, нет этой
функциональности.

## Условие

Вам, как системному программисту, поручено реализовать на языке ассемблера NASM
фреймворк предоставляющий возможность создавать и использовать генераторы в
языке Си.

_Генератор_ — это объект, позволяющий по запросу порождать следующее значение,
используя алгоритм заложенный при создании генератора. Используя генераторы
можно не создавать массив со всеми значениями, до того как начать с ним
работать, а сразу обрабатывать их по одному значению за раз, что позволяет
работать в том числе с бесконечными последовательностями.

Для решении этой задачи необходимо использовать стековый подход к реализации
генераторов (stackful generators).

### Принцип работы

Алгоритм вычисления значений определяется генераторной функцией, указатель на
которую передаётся при создании нового генератора. При запросе первого значения
генераторная функция выполняется на отдельном стеке, пока не приостановится
вычислив его. При запросе последующих значений генераторная функция продолжает
выполнятся с предыдущей точки останова. Если генераторная функция завершилась,
то этот и последующий запросы не возвращают значений.

### API

Интерфейс фреймфорка описан в заголовочном файле `generator.h`. Следующие
функции должны быть реализованы:

- `Generator makeGenerator(void (*fn)(void*), void* arg, size_t stack_size)`
  Создаёт новый генератор. При ошибке возвращает _NULL_ и выставляет
  соответствующее значение
  [errno](https://man7.org/linux/man-pages/man3/errno.3.html).  
  `entry` — указатель на генераторную функцию  
  `arg` — указатель на аргумент, передаётся в генераторную функцию  
  `stack_size` — минимальный размер стека (в байтах), который должен быть
  доступен генераторной функции. Вызов функции с параметром `stack_size` равным
  0 подразумевает, что функция не использует рекурсию и явно не аллоцирует
  память на стеке (`alloca()`), конкретный размер стека в этом случае определяет
  фреймфорк.
- `void dropGenerator(Generator gen)`  
  Освобождает динамическую память выделенную для генератора. Использование `gen`
  после вызова этой функции является _неопределённым поведением_. Вызов
  `dropGenerator(NULL)` не совершает никаких действий.
- `void* next(Generator gen)`  
  Запрашивает следующее значение генератора и возвращает указатель на него, либо
  возвращает _NULL_, если генератор больше не порождает значений. Вызов
  `next(NULL)` всегда возвращает _NULL_.
- `void yield(void* ptr);`  
  Приостанавливает выполнение генераторной функции.  
  `ptr` — указатель на вычисленное значение, передача недействительного
  указателя является _неопределённым поведением_.  
  Вызов вне функции выполняемой на стеке генератора является _неопределённым
  поведением_.

Тип `Generator` определён следующим образом:
`typedef struct Generator* Generator`, т. е. `Generator` это указатель на
анонимную структуру.

Примеры использования фреймворка можно найти в [тестах](./tests/).
